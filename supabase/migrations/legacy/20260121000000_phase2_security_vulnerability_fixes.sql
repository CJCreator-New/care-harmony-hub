-- Phase 2: Critical Security Vulnerabilities Fix
-- Address RLS Policy Security Issues

-- 1. Fix user_sessions table - overly permissive policy
DROP POLICY IF EXISTS "System can manage sessions" ON user_sessions;
CREATE POLICY "System can manage user sessions" ON user_sessions
  FOR ALL TO authenticated
  USING (
    -- Allow users to manage their own sessions
    user_id = auth.uid() OR
    -- Allow admins to manage sessions in their hospital
    EXISTS (
      SELECT 1 FROM profiles p
      JOIN user_roles ur ON ur.user_id = p.user_id
      WHERE p.user_id = auth.uid()
      AND ur.role = 'admin'
      AND p.hospital_id = (SELECT hospital_id FROM profiles WHERE user_id = user_sessions.user_id)
    )
  );

-- 2. Fix dur_criteria table - overly permissive policy
DROP POLICY IF EXISTS "DUR criteria global access" ON dur_criteria;
CREATE POLICY "DUR criteria hospital access" ON dur_criteria
  FOR ALL TO authenticated
  USING (
    hospital_id IN (
      SELECT hospital_id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- 3. Fix prediction_models table - restrict UPDATE/DELETE operations
DROP POLICY IF EXISTS "prediction_models_hospital_access" ON prediction_models;

-- Allow all authenticated users to read global models
CREATE POLICY "prediction_models_read_access" ON prediction_models
  FOR SELECT TO authenticated
  USING (true);

-- Restrict write operations to hospital staff
CREATE POLICY "prediction_models_write_access" ON prediction_models
  FOR INSERT TO authenticated
  WITH CHECK (
    hospital_id IN (
      SELECT hospital_id FROM profiles WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "prediction_models_update_access" ON prediction_models
  FOR UPDATE TO authenticated
  USING (
    hospital_id IN (
      SELECT hospital_id FROM profiles WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "prediction_models_delete_access" ON prediction_models
  FOR DELETE TO authenticated
  USING (
    hospital_id IN (
      SELECT hospital_id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- 4. Verify and fix any remaining overly permissive policies
-- Check for tables that might have USING (true) for non-SELECT operations

-- 5. Add additional security hardening

-- Ensure all sensitive tables have proper audit logging
CREATE OR REPLACE FUNCTION audit_security_events()
RETURNS TRIGGER AS $$
BEGIN
  -- Only log security-sensitive operations
  IF TG_OP IN ('INSERT', 'UPDATE', 'DELETE') AND TG_TABLE_NAME IN (
    'profiles', 'user_roles', 'medical_records', 'prescriptions', 'consultations'
  ) THEN
    INSERT INTO activity_logs (
      user_id,
      action_type,
      entity_type,
      entity_id,
      details,
      hospital_id,
      ip_address,
      user_agent,
      severity
    ) VALUES (
      auth.uid(),
      TG_OP || '_' || TG_TABLE_NAME,
      TG_TABLE_NAME,
      COALESCE(NEW.id::text, OLD.id::text),
      json_build_object(
        'operation', TG_OP,
        'table', TG_TABLE_NAME,
        'old_data', CASE WHEN TG_OP != 'INSERT' THEN row_to_json(OLD) ELSE NULL END,
        'new_data', CASE WHEN TG_OP != 'DELETE' THEN row_to_json(NEW) ELSE NULL END
      ),
      COALESCE(NEW.hospital_id, OLD.hospital_id),
      current_setting('request.headers', true)::json->>'x-forwarded-for',
      current_setting('request.headers', true)::json->>'user-agent',
      CASE
        WHEN TG_TABLE_NAME IN ('medical_records', 'prescriptions') THEN 'high'
        ELSE 'medium'
      END
    );
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply security audit triggers to critical tables
DROP TRIGGER IF EXISTS audit_security_profiles ON profiles;
CREATE TRIGGER audit_security_profiles
  AFTER INSERT OR UPDATE OR DELETE ON profiles
  FOR EACH ROW EXECUTE FUNCTION audit_security_events();

DROP TRIGGER IF EXISTS audit_security_user_roles ON user_roles;
CREATE TRIGGER audit_security_user_roles
  AFTER INSERT OR UPDATE OR DELETE ON user_roles
  FOR EACH ROW EXECUTE FUNCTION audit_security_events();

-- 6. Add rate limiting protection (database-level)
-- Create a function to check for suspicious activity patterns

CREATE OR REPLACE FUNCTION check_rate_limit(
  user_id UUID,
  action_type TEXT,
  max_attempts INTEGER DEFAULT 10,
  time_window_minutes INTEGER DEFAULT 15
)
RETURNS BOOLEAN AS $$
DECLARE
  attempt_count INTEGER;
BEGIN
  -- Count recent attempts
  SELECT COUNT(*) INTO attempt_count
  FROM activity_logs
  WHERE user_id = $1
    AND action_type = $2
    AND created_at > NOW() - INTERVAL '1 minute' * $3;

  -- Return false if rate limit exceeded
  IF attempt_count >= max_attempts THEN
    -- Log rate limit violation
    INSERT INTO activity_logs (
      user_id, action_type, entity_type, details, severity
    ) VALUES (
      $1, 'rate_limit_exceeded', 'security',
      json_build_object('action', $2, 'attempts', attempt_count),
      'high'
    );
    RETURN FALSE;
  END IF;

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Add data encryption verification
-- Function to ensure PHI data is properly encrypted before storage

CREATE OR REPLACE FUNCTION validate_phi_encryption()
RETURNS TRIGGER AS $$
BEGIN
  -- Check if sensitive fields are encrypted (basic validation)
  IF NEW.first_name IS NOT NULL AND NEW.first_name !~ '^enc_' THEN
    RAISE EXCEPTION 'PHI data must be encrypted before storage';
  END IF;

  IF NEW.last_name IS NOT NULL AND NEW.last_name !~ '^enc_' THEN
    RAISE EXCEPTION 'PHI data must be encrypted before storage';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply PHI validation to patients table
DROP TRIGGER IF EXISTS validate_phi_patients ON patients;
CREATE TRIGGER validate_phi_patients
  BEFORE INSERT OR UPDATE ON patients
  FOR EACH ROW EXECUTE FUNCTION validate_phi_encryption();

-- 8. Add session timeout enforcement
-- Function to automatically expire old sessions

CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS void AS $$
BEGIN
  -- Delete sessions older than 30 minutes (HIPAA compliant timeout)
  DELETE FROM user_sessions
  WHERE last_activity < NOW() - INTERVAL '30 minutes';

  -- Log cleanup operation
  INSERT INTO activity_logs (
    action_type, entity_type, details, severity
  ) VALUES (
    'session_cleanup', 'system',
    json_build_object('deleted_sessions', FOUND),
    'info'
  );
END;
$$ LANGUAGE plpgsql;

-- Create a scheduled job to run session cleanup (would be called by cron/external scheduler)
-- For now, we'll create a manual function that can be called

-- 9. Final security verification
-- Create a view to show current RLS policy status

CREATE OR REPLACE VIEW security_policy_status AS
SELECT
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- Grant access to security monitoring
GRANT SELECT ON security_policy_status TO authenticated;

COMMENT ON VIEW security_policy_status IS 'Security monitoring view to track RLS policy status';